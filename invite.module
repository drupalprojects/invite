<?php

/** 
 * @file 
 * The invite.module provides a GMail-style 'Invite a friend' feature. It
 * allows your users to send and track invitations to join your site.
 */ 

define('INVITE_MAX_INVITES',  0);
define('INVITE_MAX_PER_TURN', 1);

/** 
 * Implementation of hook_help(). 
 */ 
function invite_help($section) {
  switch ($section) {
    case 'admin/modules#description':
      return t('Allows users to send GMail style invitations, and automatically escalates new users who join the site to a role of your designation.');
      
    case 'invite':
      return _invite_get_help_text();
  }
}

/**
 * Implementation of hook_perm().
 */
function invite_perm() {
  return array('send invitations');
} 

/**
 * Implementation of hook_settings().
 */
function invite_settings() {
  $target_roles = $roles = user_roles();
  unset($target_roles[DRUPAL_ANONYMOUS_RID]);

  $form['user_settings'] = array(
    '#type' => 'fieldset',
    '#title' => t('User settings'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );

  // Define target roles for new members
  $form['user_settings']['invite_target_role_default'] = array(
    '#type' => 'select',
    '#title' => t('Target role (default)'),
    '#default_value' => variable_get('invite_target_role_default', DRUPAL_AUTHENTICATED_RID),
    '#options' => $target_roles,
    '#description' => t('Choose the default role that invited users will be added to when they register. For example, <em>authenticated user</em>.'),
    '#required' => TRUE,
  );
  
  foreach ($roles as $role) {
    $role_no_space = str_replace(' ', '_', $role);
    $form['user_settings']['invite_target_role_'. $role_no_space] = array(
      '#type' => 'select',
      '#title' => t('Target role for %role invitees', array('%role' => $role)),
      '#default_value' => variable_get('invite_target_role_'. $role_no_space, DRUPAL_AUTHENTICATED_RID),
      '#options' => $target_roles,
      '#description' => t('Choose the role that invited users will be added to if invited by a %role.', array('%role' => $role)),
      '#required' => TRUE,
    );
  }

  // Set invite expiry
  $form['user_settings']['invite_expiry'] = array(
    '#type' => 'select',
    '#title' => t('Invitation expiry'),
    '#default_value' => variable_get('invite_expiry', 30),
    '#options' => drupal_map_assoc(array(5, 10, 15, 20, 25, 30, 45, 60)),
    '#description' => t('Set the expiry period for user invitations, in days.'),
    '#multiple' => FALSE,
    '#required' => TRUE,
  );  

  // Allow deleting accepted invitations
  $form['user_settings']['invite_allow_join_delete'] = array(
    '#type' => 'checkbox',
    '#title' => t('Allow deletion of joined users'),
    '#default_value' => variable_get('invite_allow_join_delete', 0),
    '#description' => t('This option allows users to delete invitations marked as <em>joined</em>. Useful to prevent users from deleting their account to be re-invited.')
  );

  // Limit number of invites per role
  $form['user_roles'] = array(
    '#type' => 'fieldset',
    '#title' => t('Role limitations'),
    '#tree' => FALSE,
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );
  
  foreach ($roles as $role) {
    $role_no_space = str_replace(' ', '_', $role);
    $form['user_roles']['invite_maxnum_'. $role_no_space] = array(
      '#type' => 'select',
      '#title' => t('Limit for %role', array('%role' => theme_placeholder($role))),
      '#default_value' => variable_get('invite_maxnum_'. $role_no_space, INVITE_MAX_INVITES),
      '#options' => array(5 => 5, 10 => 10, 20 => 20, 50 => 50, 100 => 100, 500 => 500, 1000 => 1000, 0 => t('unlimited')),
      '#description' => t('Allows to limit the total number of invitations a %role can send.', array('%role' => theme_placeholder($role))),
      '#multiple' => FALSE,
      '#required' => TRUE,
    );
  }
  
  // Limit number of invites per turn
  $form['multi_invites'] = array(
    '#type' => 'fieldset',
    '#title' => t('Multiple invitations'),
    '#tree' => FALSE,
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );
  
  foreach ($roles as $role) {
    $role_no_space = str_replace(' ', '_', $role);
    $form['multi_invites']['invite_maxmultiple_'. $role_no_space] = array(
      '#type' => 'select',
      '#title' => t('Limit per turn for %role', array('%role' => theme_placeholder($role))),
      '#default_value' => variable_get('invite_maxmultiple_'. $role_no_space, INVITE_MAX_PER_TURN),
      '#options' => array(1 => '1 ('. t('disabled') .')', 5 => 5, 10 => 10, 100 => 100, 0 => t('unlimited')),
      '#description' => t('Allows to limit the maximum number of invitations a %role can send per turn.', array('%role' => theme_placeholder($role))),
      '#multiple' => FALSE,
      '#required' => TRUE,
    );
  }
  
  // Email settings
  $form['email_settings'] = array(
    '#type' => 'fieldset',
    '#title' => t('Email settings'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );

  $form['email_settings']['invite_subject'] = array(
    '#type' => 'textfield',
    '#title' => t('Subject'),
    '#default_value' => variable_get('invite_subject', t("You've been invited")),
    '#size' => 20,
    '#maxlength' => 64,
    '#description' => t('Type the subject of the invitation email.'),
    '#required' => TRUE,
  );
  
  $form['email_settings']['invite_default_mail_template'] = array(
    '#type' => 'textarea',
    '#title' => t('Mail template'),
    '#default_value' => _invite_get_mail_template(),
    '#required' => TRUE,
    '#description' => t('Use the following placeholders: %site, %homepage, %join_link, %message, %inviter.'),
  );

  $form['email_settings']['invite_use_users_email'] = array(
    '#type' => 'radios',
    '#title' => t('<em>From</em> email address'),
    '#description' => t('Choose which email address will be in the From: header for the invitation mails sent; <em>site</em> or <em>inviter</em>. <em>Site</em> will use the default email address of the site, whereas <em>inviter</em> will use the email address of the user who is sending the invitation. Alternatively, you can set this value manually by clicking on <em>advanced settings</em> below.'),
    '#options' => array(t('site'), t('inviter')),
    '#default_value' => variable_get('invite_use_users_email', 0),
  );

  $form['email_settings']['invite_use_users_email_replyto'] = array(
    '#type' => 'radios',
    '#title' => t('<em>Reply-To</em> email address'),
    '#description' => t('Choose which email address will be in the Reply-To: header for the invitation mails sent; <em>site</em> or <em>inviter</em>. <em>Site</em> will use the default email address of the site, whereas <em>inviter</em> will use the email address of the user who is sending the invitation. Alternatively, you can set this value manually by clicking on <em>advanced settings</em> below.'),
    '#options' => array(t('site'), t('inviter')),
    '#default_value' => variable_get('invite_use_users_email_replyto', 0),
  );

  $form['email_settings']['advanced'] = array(
    '#type' => 'fieldset',
    '#title' => t('Advanced settings'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#description' => t('<strong>Note:</strong> unless these fields are blank, they will override the radio button choices above.')
  );

  $form['email_settings']['advanced']['invite_manual_from'] = array(
    '#type' => 'textfield', 
    '#title' => t('Manually override <em>From</em> email address'), 
    '#default_value' => variable_get('invite_manual_from', NULL), 
    '#description' => t('The email address the invitation email is sent from.')
  );

  $form['email_settings']['advanced']['invite_manual_reply_to'] = array(
    '#type' => 'textfield', 
    '#title' => t('Manually override <em>Reply-To</em> email address'), 
    '#default_value' => variable_get('invite_manual_reply_to', NULL), 
    '#description' => t('The email address you want recipients to reply to.')
  );

  // Invite page customization
  $form['invite_page'] = array(
    '#type' => 'fieldset',
    '#title' => t('Invite page customization'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );

  $form['invite_page']['invite_page_title'] = array(
    '#type' => 'textfield', 
    '#title' => t('Invite page title'), 
    '#default_value' => variable_get('invite_page_title', t('Invite your friends and colleagues')), 
    '#description' => t('The title of the page where users invite friends.'),
    '#required' => TRUE
  );

  $form['invite_page']['invite_help_text'] = array(
    '#type' => 'textarea',
    '#title' => t('Invite help text'),
    '#default_value' => _invite_get_help_text(),
    '#required' => FALSE,
    '#description' => t('Customize the text that appears above the email form on the invite page for users.'),
  );

  return $form;
}

/**
 * Implementation of hook_menu().
 */
function invite_menu($may_cache) {
  global $user;
  $items = array();

  if ($may_cache) {
    $items[] = array(
      'path' => 'invite',
      'title' => variable_get('invite_page_title', t('Invite your friends and colleagues')),
      'callback' => 'invite_page',
      'access' => user_access('send invitations'),
      'type' => MENU_NORMAL_ITEM);
    $items[] = array(
      'path' => 'invite/delete', 
      'callback' => 'invite_delete',
      'access' => user_access('send invitations'),
      'type' => MENU_CALLBACK);
  }
  else if ($user->uid && user_access('send invitations')) {
    // Check for newly registered users
    _invite_check_messages($user->uid);
  }

  return $items;
}
 
/**
 * Implementation of hook_form_alter().
 */
function invite_form_alter($form_id, &$form) {
  switch ($form_id) {
    case 'user_configure_settings':
      // Add new registration mode
      $form['registration']['user_register']['#options']['inviteonly'] = t('New user registration by invitation only.');
      break;

    case 'user_register':
      $valid_invite = FALSE;
      if ($code = arg(2)) {
        // Check for valid invite code
        if ($invite = _invite_fetch_invite($code)) {
          $form['mail']['#default_value'] = $invite->email;
          $valid_invite = (!$invite->expired);
          $form['invite_code'] = array(
            '#type' => 'value',
            '#value' => $code,
          );
          $form['invite_referrer'] = array(
            '#type' => 'value',
            '#value' => $invite->referrer,
          );
        }
      }

      $user_admin = user_access('administer users');
      $invite_only = (variable_get('user_register', 1) == 'inviteonly');
      if ((!$user_admin) && $invite_only) {
        if (!$valid_invite) {
          if ($invite->expired) {
            drupal_set_message(t('Sorry, this invitation code has expired.'));
          }
          else {
            drupal_set_message(t('Sorry, new user registration by invite only.'));
          }
          // Redirect to standard login form
          drupal_goto('user');
        }
        else if (isset($form['#submit']['user_register_submit'])) {
          // If we are in invite only mode, hijack the usual user registration
          // submission
          $form['#submit'] = array('invite_register_submit' => array());
        }
      }
      break;

    case 'user_login_block':
      // Remove temptation for non members to try and register
      if (variable_get('user_register', 1) == 'inviteonly') {
        $new_items = array();
        $new_items[] = l(t('Request new password'), 'user/password', array('title' => t('Request new password via e-mail.')));
        $form['links']['#value'] = theme('item_list', $new_items);
      }
      break;
  } 
}

/**
 * Forms API callback; overrides user_register_submit().
 *
 * Perform invite validation on user registration submission for invite-only
 * sites. Checks for a valid invitation before passing control back to the
 * core user registration.
 */
function invite_register_submit($form_id, $form_values) {
  // No need to check for invite only mode as invite_form_alter has already
  // done that
  if ($invite = _invite_fetch_invite($form_values['invite_code'])) {
    if (!$invite->expired) {
      return user_register_submit($form_id, $form_values);
    }
    else {
      drupal_set_message(t('Sorry, this invitation code has expired.'));
    }
  }
  else {
    drupal_set_message(t('You have not been invited to join this site.'));
    watchdog('invite', t('Uninvited user registration attempt.'), WATCHDOG_WARNING);
  }
  return '<front>';
}

/**
 * Implementation of hook_user().
 */
function invite_user($op, &$edit, &$account, $category = NULL) { 
  switch ($op) {
    case 'insert':
      if (isset($edit['invite_code'])) {
        // Check for valid tracking code
        if ($invite = _invite_fetch_invite($edit['invite_code'])) {
          if (!$invite->expired) {
            // Update invite status
            _invite_set_timestamp($edit['mail'], $account->uid, $edit['invite_code']);

            // Escalate user role
            _invite_role_escalate($account);

            // Approve user account
            _invite_unblock($account->uid);
          }
        } 
        else {
          watchdog('invite', t('Registration code failed for %name %email.', array('%name' => theme_placeholder($account->name), '%email' => theme_placeholder('<'. $account->mail .'>'))), WATCHDOG_NOTICE, l(t('view'), 'user/'. $account->uid));
        }
      }
      break;

    case 'delete':
      // Only delete invites of existing users if the configuration allows it to
      $delete_joined = variable_get('invite_allow_join_delete', 0);

      // Delete invite for this user
      if ($delete_joined) {
        db_query("DELETE FROM {invite} WHERE mid = %d", $account->uid);
      }

      // Delete any invites originating from this user
      $sql = "DELETE FROM {invite} WHERE uid = %d";
      if (!$delete_joined) {
        $sql .= " AND timestamp != 0";
      }
      db_query($sql, $account->uid);
      break;
  }
}

/**
 * Implementation of hook_cron().
 */
function invite_cron() {
  // TODO: cron should check which invitations are expired and possibly send a follow up mail
  // This should also trigger a module_invoke_all('invite', 'expire', $args) call so that other modules can 
  // react to the expired invitation.
}

/**
 * Menu callback; displays the invite form.
 */
function invite_page(){
  global $user;
  
  //this displays all invites for a user, and counts how many invites they have left to give
  $form['invitations'] = array(
    '#type' => 'fieldset',
    '#title' => t('Your invitations'),
  );

  $inc = 0;
  $access_profiles = user_access('access user profiles');
  $result = db_query("SELECT i.*, u.uid FROM {invite} i LEFT JOIN {users} u ON u.uid = i.mid AND u.uid != 0 WHERE i.uid = %d ORDER BY i.expiry DESC", $user->uid);
  while ($invite = db_fetch_object($result)){
    $delete_link = l(t('Delete invitation'), 'invite/delete/'. urlencode($invite->email));
    if (!$invite->timestamp) {
      $email_cell = check_plain($invite->email);
      $status_cell = ($invite->expiry < time()) ? t('Expired') : t('Pending');
      $action_cell = $delete_link;
    }
    else {
      $account_exists = !empty($invite->uid);
      if ($access_profiles) {
        $email_cell = $account_exists ? l($invite->email, 'user/'. $invite->mid, array('title' => t('View user profile.'))) : '<em>'. check_plain($invite->email) .'</em>';
      }
      else {
        $email_cell = $account_exists ? check_plain($invite->email) : '<em>'. check_plain($invite->email) .'</em>';
      }
      $status_cell = $account_exists ? t('Joined') : t('Deleted');
      $action_cell = variable_get('invite_allow_join_delete', 0) ? $delete_link : '&nbsp;';
    }
    $items[] = array($email_cell, $status_cell, $action_cell);
    $inc++;
  }
  
  if (count($items) > 0) {
    $headers = array(t('Email'), t('Status'), '&nbsp;');
    $table = theme('table', $headers, $items, array('id' => 'invite_table'));
  }
  else {
    $table = t('You have not sent any invitations yet.');
  }
  $form['invitations']['table'] = array(
    '#type' => 'markup',
    '#value' => $table,
  );
  
  $form['invite_form'] = array(
    '#type' => 'fieldset',
    '#title' => t('Invite a friend'),
  );      
  
  $maximum_invites = _invite_max_invites_by_role();
  if ($maximum_invites > 0) {
    $invites_left = $maximum_invites - $inc;
    $form['invite_form']['markup_remaining_invites'] = array(
      '#type' => 'markup',
      '#value' => ($invites_left > 0)
        ? format_plural($invites_left, 'You have one invite left.', 'You have %count invites left.')
        : t('Maximum number (%max) of invitations reached.', array('%max' => $maximum_invites)),
    );
    $form['invite_form']['remaining_invites'] = array(
      '#type' => 'value',
      '#value' => $invites_left,
    );
  }
  
  //the invitation form
  if ($inc < $maximum_invites  || $maximum_invites == 0){
    $maximum_multiple = _invite_max_invites_per_turn();
    
    if (isset($_SESSION['invite_failed_emails'])) {
      $failed_emails = implode("\n", (array)unserialize($_SESSION['invite_failed_emails']));
      unset($_SESSION['invite_failed_emails']);
    }
    
    if ($maximum_multiple != 1) {
      $form['invite_form']['email'] = array(
        '#type' => 'textarea',
        '#default_value' => $failed_emails,
        '#rows' => 2,
        '#required' => TRUE,
      );
    }
    else {
      $form['invite_form']['email'] = array(
        '#type' => 'textfield',
        '#default_value' => '',
        '#maxlength' => 64,
        '#required' => TRUE,
      );
    }
    if ($failed_emails) {
      $form['invite_form']['email']['#attributes']['class'] = 'error';
    }
    $form['invite_form']['email']['#title'] = format_plural($maximum_multiple, 'Email', 'Email(s)');
    $form['invite_form']['email']['#description'] = format_plural($maximum_multiple, 'Type the email of the person you would like to invite.', 'Type the email address(es) of the person(s) you would like to invite.');

    $form['invite_form']['message'] = array(
      '#type' => 'textarea',
      '#title' => t('Your message'),
      '#default_value' => '',
      '#required' => FALSE,
      '#description' => format_plural($maximum_multiple, 'This message will be added to the mail sent to the person you are inviting.', 'This message will be added to the mail sent to the person(s) you are inviting.'),
    );
    $form['invite_form']['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Submit'),
    );
  }


  return drupal_get_form('_invite_form', $form);
}

/**
 * Converts a string containing one or more email addresses into an array.
 *
 * Also filters out invalid emails and stores them in a session variable for
 * later redisplay.
 *
 * @param $string
 *   The string to process. recognized delimiters are comma, newline and
 *   carriage return.
 *
 * @return All valid email addresses as an array.
 */
function _invite_get_emails($string) {
  $valid_emails = $failed_emails = array();
  $emails = array_unique(split("[,\n\r]", $string));
  foreach ($emails as $email) {
    $email = trim($email);
    if ($email) {
      if (valid_email_address($email)) {
        $valid_emails[] = $email;
    	}
      else {
        $failed_emails[] = $email;
      }
    }
  }
  if (count($failed_emails)) {
    $_SESSION['invite_failed_emails'] = serialize($failed_emails);
  }
  return $valid_emails;
}

/**
 * Forms API callback; validates the incoming form data.
 *
 * Filters out emails that are already registered or have been invited before.
 * Checks the invite limit of the user and the max. number of invites per turn.
 */
function _invite_form_validate($form_id, &$edit) {
  global $user;

  $emails = _invite_get_emails($edit['email']);

  if (count($emails)) {
    // Filter out already registered users, but pass validation
    $failed_emails = _invite_validate_emails("SELECT mail AS email FROM {users} WHERE mail IN (%s)", $emails);
    if (count($failed_emails)) {
      $error = format_plural(count($failed_emails), 'The following recipient has already registered:', 'The following recipients have already registered:') .'<br />';
      foreach ($failed_emails as $key => $email) {
        $account = user_load(array('mail' => $email));
        $failed_emails[$key] = theme('username', $account) .' ('. check_plain($email) .')';
      }
      $error .= implode(', ', $failed_emails);
      drupal_set_message($error, 'error');
    }
  
    // Filter out already invited users, but pass validation
    $failed_emails = _invite_validate_emails("SELECT email FROM {invite} WHERE email IN (%s)", $emails);
    if (count($failed_emails)) {
      $error = format_plural(count($failed_emails), 'The following recipient has already been invited:', 'The following recipients have already been invited:') .'<br />';
      $error .= implode(', ', array_map('check_plain', $failed_emails));
      drupal_set_message($error, 'error');
    }
  
    // Check invite limit, fail to let the user choose which ones to send
    if (isset($edit['remaining_invites']) && count($emails) > $edit['remaining_invites']) {
      form_set_error('email', format_plural($edit['remaining_invites'], 'You have only one invitate left.', 'You have only %count invitates left.'));
      return;
    }
  
    // Check limit per turn
    $maximum_per_turn = _invite_max_invites_per_turn();
    if ($maximum_per_turn > 0 && count($emails) > $maximum_per_turn) {
      form_set_error('email', format_plural($maximum_per_turn, 'You can send only one invitation per turn.', 'You cannot send more than %count invitations per turn.'));
      return;
    }

    // Save valid emails
    form_set_value(array('#parents' => array('validated_emails')), $emails);
  }
}

/**
 * Forms API callback; processes the incoming form data.
 *
 * Sends out invitation emails.
 */
function _invite_form_submit($form_id, $edit) {
  global $user;

  $count_failed = $count_success = 0;

  if (isset($_SESSION['invite_failed_emails'])) {
    $failed_emails = (array)unserialize($_SESSION['invite_failed_emails']);
    $count_failed = count($failed_emails);
  }
  
  if (is_array($edit['validated_emails'])) {
    foreach ($edit['validated_emails'] as $email) {
      // Generate code for each mail
      $code = _invite_create_regcode();
      $message = trim($edit['message']);
  
      // Send email
      if (_invite_send_invite('mail', $user->name, $email, $code, $message)) {
        db_query("INSERT INTO {invite} (email, reg_code, uid, expiry, message) VALUES ('%s', '%s', %d, %d, '%s')", $email, $code, $user->uid, time()+(variable_get('invite_expiry', 30)*60*60*24), $message);
        
        // Notify other modules
        $args = array('inviter' => $user);
        module_invoke_all('invite', 'invite', $args);
        $count_success++;  
      }
      else {
        $failed_emails[] = $email;
        $count_failed++;
      }
    }
  }

  if ($count_success) {
    $success = format_plural($count_success, '%count invite has been successfully sent.', '%count invites have been successfully sent.');
    drupal_set_message($success);
  }
  if ($count_failed) {
    $_SESSION['invite_failed_emails'] = serialize($failed_emails);
    $error = format_plural($count_failed, '%count entered email is invalid. Please correct it.', '%count entered emails are invalid. Please correct them.');
    drupal_set_message($error, 'error');
  }
}

/**
 * Menu callback; deletes an invite record.
 *
 * @param $email
 *   Urlencode()'d email address of the invite record to remove.
 */
function invite_delete($email) {
  global $user;

  $email = urldecode($email);

  if ($email != '') {
    $invite = db_fetch_object(db_query("SELECT uid AS inviter, timestamp FROM {invite} WHERE email = '%s'", $email));
    // Inviter must match current user
    if ($invite->inviter == $user->uid) {
      // Verify that invite may be deleted
      if (!$invite->timestamp || variable_get('invite_allow_join_delete', 0)) {
        _invite_delete($email, $user->uid);
        drupal_set_message(t('Invitation to %email has been deleted.', array('%email' => theme_placeholder($email))));
      }
      else {
        drupal_set_message(t('Invitations to registered users cannot be deleted.'));
      }
    }
    else {
      watchdog('invite', t('Detected malicious attempt to delete an invitation.'), WATCHDOG_WARNING, l(t('view'), 'user/'. $user->uid));
    }
  }
  drupal_goto('invite');
}

/**
 * @{
 * Module specific helper functions.
 */

/**
 * Returns how many invites a user may send.
 *
 * @param $uid
 *   The user id to retrieve the invites limit for.
 */
function _invite_max_invites_by_role($uid = NULL) {
  return _invite_get_max_by_role('maxnum', INVITE_MAX_INVITES, $uid);
}

/**
 * Returns how many invites may be sent per turn.
 *
 * @param $uid
 *   The user id to retrieve the per-turn limit for.
 */
function _invite_max_invites_per_turn($uid = NULL) {
  return _invite_get_max_by_role('maxmultiple', INVITE_MAX_PER_TURN, $uid);
}

/**
 * Helper function; lookup role-dependent variable value.
 *
 * @param $var
 *   Variable whose value to return.
 * @param $default
 *   Default value if requested variable is unset.
 * @param $uid
 *   User whose role(s) should be taken into account. Defaults to current user.
 *
 * @return The numeric maximum of all found variable values.
 */
function _invite_get_max_by_role($var, $default, $uid = NULL) {
  global $user;
  
  $result = 0;
  $account = (is_null($uid)) ? $user : user_load(array('uid' => $uid));

  foreach (user_roles() as $role) {
    $role_no_space = str_replace(' ', '_', $role);
    if (in_array($role, $account->roles)) {
      $variable = 'invite_'. $var .'_'. $role_no_space;
      $role_max = variable_get($variable, $default);
      if ($role_max == 0) {
        return 0;
      }
      if ($role_max > $result) {
        $result = $role_max;
      }
    }
  }
  return $result;
}

/**
 * Helper function; filters out emails based on a database query.
 *
 * @param $sql
 *   The database query to execute. The query is expected to conatain one
 *   replacement variable, namely a <code>IN(%s)</code> construct, where
 *   the given list of email addresses will be inserted.
 * @param &$emails
 *   The list of email addresses to validate. When this function returns, all
 *   invalid emails have already been removed.
 *
 * @return The list of failed email addresses.
 */
function _invite_validate_emails($sql, &$emails) {
  $failed_emails = array();
  $emails_sql = "'". implode("','", array_map('db_escape_string', $emails)) ."'";
  $result = db_query(sprintf($sql, $emails_sql));
  while ($row = db_fetch_object($result)) {
    $failed_emails[] = $row->email;
  }
  // Leave only valid emails
  $emails = array_diff($emails, $failed_emails);
  return $failed_emails;
}

/**
 * Escalates an invited user's role(s), based on the role(s) of the inviter.
 *
 * @param $invitee
 *   A user object.
 */
function _invite_role_escalate($invitee) {
  // Default target role
  $roles = array('default');

  // Add roles of inviter
  $inviter_uid = db_result(db_query("SELECT uid FROM {invite} WHERE mid = %d", $invitee->uid));
  if ($inviter_uid && $inviter = user_load(array('uid' => $inviter_uid))) {
    $roles = array_merge($roles, $inviter->roles);
  }

  // Map to configured target roles
  $targets = array();
  foreach ($roles as $role) {
    $role_no_space = str_replace(' ', '_', $role);
    $target = variable_get('invite_target_role_'. $role_no_space, DRUPAL_AUTHENTICATED_RID);
    if ($target != DRUPAL_AUTHENTICATED_RID) {
      $targets[$target] = $target;
    }
  }

  // Notify other modules of changed user
  $edit = array('roles' => $targets);
  user_module_invoke('update', $edit, $invitee);

  // Save new user role(s)
  foreach ($targets as $target) {
    db_query("DELETE FROM {users_roles} WHERE uid = %d AND rid = %d", $invitee->uid, $target);
    db_query("INSERT INTO {users_roles} (uid, rid) VALUES (%d, %d)", $invitee->uid, $target);
  }
  
  // Notify other modules of role escalation
  $args = array(
    'invitee' => $invitee,
    'inviter' => $inviter,
    'roles' => $targets
  );
  module_invoke_all('invite', 'escalate', $args);
}

/**
 * Marks an invitation as 'joined'.
 *
 * @param $email
 *   The email address the invitee actually used in the registration.
 * @param $uid
 *   The user id of the newly registered user.
 * @param $regcode
 *   The tracking code of the originating invite.
 */
function _invite_set_timestamp($email, $uid, $regcode){
  db_query("UPDATE {invite} SET timestamp = %d, mid = %d, email = '%s' WHERE reg_code = '%s'", time(), $uid, $email, $regcode);
}

/**
 * Displays a notification message when an invited user has registered.
 *
 * @param $uid
 *   The user id to check accepted invitations for.
 */
function _invite_check_messages($uid) {
  $result = db_query('SELECT i.mid, i.email FROM {invite} i INNER JOIN {users} u ON u.uid = i.mid AND u.status = 1 WHERE i.uid = %d AND i.timestamp != 0 AND i.received = 0', $uid);
  while ($invite = db_fetch_object($result)) {
    $account = user_load(array('uid' => $invite->mid));
    drupal_set_message(t('%user (%email) has joined %site-name!', array('%user' => theme('username', $account), '%email' => check_plain($invite->email), '%site-name' => check_plain(variable_get('site_name', t('Drupal'))))));
    db_query("UPDATE {invite} SET received = 1 WHERE email = '%s'", $invite->email);
  }
}

/**
 * Creates a unique tracking code.
 *
 * @return An 8-digit long, unique tracking code.
 */
function _invite_create_regcode(){
  do {
    $reg_code = user_password(8);
    $r = db_query("SELECT COUNT(*) FROM {invite} WHERE reg_code = '%s'", $reg_code);
  } while ((int)db_result($r) > 0);
  return $reg_code;
}

/**
 * Prepares and sends an invite to the specified email address.
 */
function _invite_send_invite($op, $user_name, $email, $code, $message) {
  global $base_url, $user;

  $headers  = array();
  $from_site = variable_get('site_mail', ini_get('sendmail_from'));

  // Manual settings override custom settings below
  // Note: default value must be NULL to comply with legacy Drupal versions
  $from = variable_get('invite_manual_from', NULL);
  $reply_to = variable_get('invite_manual_reply_to', NULL);

  // Set custom From and Reply-To headers
  if (!$from) {
    if ($user->uid && variable_get('invite_use_users_email', 0)) {
      $from = $user->mail;
    }
    else if ($from_site) {
      $from = $from_site;
    }
  }
  if ($from) {
    $headers[] = 'From: '. $from;
  }
  if (!$reply_to) {
    if ($user->uid && variable_get('invite_use_users_email_replyto', 0)) {
      $reply_to = $user->mail;
    }
    else if ($from_site) {
      $reply_to = $from_site;
    }
  }
  if ($reply_to) {
    $headers[] = 'Reply-To: '. $reply_to;
  }
  $header = count($headers) > 0 ? implode("\n", $headers) : NULL;

  $subject = variable_get('invite_subject',t("You've been invited"));
  $template = _invite_get_mail_template();
  $site = variable_get('site_name', t('Drupal'));
  $join_link = url('user/register/'. $code, NULL, NULL, TRUE);
  $homepage = $base_url;
  $inviter = $user_name;

  $body = t($template, array('%site' => $site, '%join_link' => $join_link, '%homepage' => $homepage, '%message' => $message, '%inviter' => $inviter));

  switch ($op){
    case "mail":
      if (!($success = user_mail($email, $subject, wordwrap($body, 72), $header))) {
        static $error_shown = FALSE;
        if (!$error_shown) {
          drupal_set_message(t('Problems occurred sending the invitation(s). Please contact the site administrator.'), 'error');
          $error_shown = TRUE;
        }
        watchdog('invite', t("Failed sending invitation. To: %email From: %from", array('%email' => check_plain($email), '%from' => check_plain($from))));
      }
      return $success;
  }
}

/**
 * Returns the configured or default email template.
 *
 * @return The localized email body.
 */
function _invite_get_mail_template() {
  $template = t("Your friend, %inviter has invited you to join %site [%homepage].

To become a member of %site, click the link below or paste it into the address bar of your browser. 

%join_link

----------

%message");

  return variable_get('invite_default_mail_template', $template);
}

/**
 * Returns the introductory help text for the invites page.
 *
 * @return The localized intro text.
 */
function _invite_get_help_text() {
  $help = t("<p>This is an overview of the invitations you have sent. The status of each invitation is shown:
<ul>
  <li><strong>Joined</strong>: Shows that the person you have invited has used your invitation to join the site. Click on the email address to take you to their profile page.</li>
  <li><strong>Pending</strong>: The invitation has been sent, but your friend has still not accepted the invitation. You may send a reminder, by clicking the 'Remind Me' link.</li>
  <li><strong>Expired</strong>: The invitation has not been used to register on the site within the expiration period.</li>
</ul>
</p>
<p>At any time, you may delete either 'Pending' or 'Expired' invitations. 'Joined' invitation cannot be deleted and count permanently toward your invitation allotment.</p>");

  return variable_get('invite_help_text', $help);
}

/**
 * Approves the account of an invited user.
 *
 * Invited users are always automatically approved (ie. unblocked).
 *
 * @param $uid
 *   The user id to unblock.
 */
function _invite_unblock($uid) {
  db_query("UPDATE {users} SET status = 1 WHERE uid = %d", $uid);
}

/**
 * Fetches a valid invite record from the database.
 *
 * A valid invite is one whose tracking code hasn't been used before.
 *
 * @param $invite_code
 *   The tracking code to lookup the invite for.
 */
function _invite_fetch_invite($invite_code) {
  $result = db_query("SELECT email, uid AS referrer, expiry FROM {invite} WHERE reg_code = '%s' AND timestamp = 0", $invite_code);
  if ($invite = db_fetch_object($result)) {
    $invite->expired = ($invite->expiry < time() ? TRUE : FALSE);
  }
  return $invite;
}

/**
 * Deletes an invite database record.
 *
 * @param $email
 *   The email address of the invte record to remove.
 * @param $inviter_uid
 *   The user id of the inviting user.
 */
function _invite_delete($email, $inviter_uid) {
  global $user;
  db_query("DELETE FROM {invite} WHERE email = '%s'", $email);
  $inviter = ($user->uid == $inviter_uid) ? $user : user_load(array('uid' => $inviter_uid));

  // Notify other modules
  $args = array('inviter' => $inviter, 'email' => $email);
  module_invoke_all('invite', 'cancel', $args);
}

